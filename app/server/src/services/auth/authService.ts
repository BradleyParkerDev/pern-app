import { Request, Response } from 'express';
import authServerUtil from '@server/lib/auth/authServerUtil.js';
import { Session } from '@server/database/schemas/index.js';
import { userHelper } from '@/server/src/services/helpers/user/userHelper.js';
import { awsHelper } from '../helpers/aws/awsHelper.js';
import type { AccessTokenType } from '@shared/types/server/auth/index.js';
import { db } from '@server/database/db.js';
import { eq } from 'drizzle-orm';
import { loggerFactory } from '@server/lib/logger/index.js';

export const createAuthService = (req?: Request, res?: Response) => {
	/**
	 * Type guard for JWT payloads generated by this service.
	 */
	const isAccessTokenPayload = (
		payload: unknown,
	): payload is AccessTokenType => {
		if (!payload || typeof payload !== 'object') return false;
		const candidate = payload as Record<string, unknown>;
		return (
			typeof candidate.sessionId === 'string' &&
			typeof candidate.sessionType === 'string' &&
			typeof candidate.exp === 'number'
		);
	};

	const authService = {
		// Per-request context for downstream auth helpers
		req,
		res,
		util: authServerUtil,
		user: userHelper,
		aws: awsHelper,

		/**
		 * Validate token, hydrate request with session info, or create a new session.
		 */
		async authCheck(accessToken: string) {
			// Validate token, hydrate request with session info, or create a new session

			try {
				const decodedToken = await this.util.verifyToken(accessToken);
				if (!decodedToken) {
					await this.createUserSession();
					return;
				}
				if (isAccessTokenPayload(decodedToken)) {
					const sessionId = decodedToken.sessionId;

					const [sessionData] =
						await this.getUserSessionData(sessionId);

					if (this.req && sessionData) {
						this.req.body ??= {};
						// Attach IDs for downstream middleware/controllers
						this.req.body.userId = sessionData.userId ?? undefined;
						this.req.body.sessionId = sessionId;

						loggerFactory.authService.info(
							`[Auth Check] - sessionType: ${this.req.body.userId ? 'Authenticated' : 'Guest'} - sessionId: ${this.req.body.sessionId}`,
						);

						return;
					}

					await this.createUserSession();
					return;
				} else {
					await this.createUserSession();
				}
			} catch {}
		},
		/**
		 * Create a user or guest session and set the session cookie.
		 */
		async createUserSession(userId?: string) {
			// Replace any existing session cookie before issuing a new one
			this.removeSessionCookie();
			const expirationMs = this.util.expiration.sevenDays;
			const tokenTtlMs = Math.max(0, expirationMs - Date.now());
			if (userId) {
				// Create authenticated session

				const [session] = await db
					.insert(Session)
					.values({
						userId: userId,
						expirationTime: new Date(expirationMs),
					})
					.returning();
				if (!session) return;
				// Use absolute expiration time for JWT and TTL for cookie
				const tokenExpirationSeconds = Math.floor(expirationMs / 1000);

				const payload = {
					sessionType: 'Authneticated',
					sessionId: session.sessionId,
					exp: tokenExpirationSeconds,
				};

				console.log(payload);
				// Sign access token and set cookie
				const accessToken = await this.util.generateToken(payload);

				this.setSessionCookie(accessToken, tokenTtlMs);

				loggerFactory.authService.info(
					`[New Session] - sessionType: Authenticated - userId: ${userId}`,
				);

				const userData = await this.user.getUserData({
					userId: userId,
				});
			} else {
				// Create guest session
				const [session] = await db
					.insert(Session)
					.values({
						expirationTime: new Date(expirationMs),
					})
					.returning();
				if (!session) return;
				// Use absolute expiration time for JWT and TTL for cookie
				const tokenExpirationSeconds = Math.floor(expirationMs / 1000);

				const payload = {
					sessionType: 'Guest',
					sessionId: session.sessionId,
					exp: tokenExpirationSeconds,
				};

				console.log(payload);
				// Sign access token and set cookie
				const accessToken = await this.util.generateToken(payload);

				this.setSessionCookie(accessToken, tokenTtlMs);
				loggerFactory.authService.info(
					`[New Session] - sessionType: Guest - sessionId: ${payload.sessionId}`,
				);
			}
		},
		/**
		 * Fetch session data for a given session ID.
		 */
		async getUserSessionData(sessionId: string) {
			// TODO: check if session expired and handle accordingly
			return await db
				.select()
				.from(Session)
				.where(eq(Session.sessionId, sessionId));
		},
		/**
		 * Delete a session by ID and return the deleted record.
		 */
		async deleteUserSession(sessionId: string) {
			// Implementation for deleting a user session
			return await db
				.delete(Session)
				.where(eq(Session.sessionId, sessionId))
				.returning();
		},
		/**
		 * Persist the access token on the client as an HTTP-only cookie.
		 */
		setSessionCookie(accessToken: string, tokenExpiration: number) {
			// Persist access token on the client
			this.res?.cookie('sessionCookie', accessToken, {
				httpOnly: true,
				secure: process.env.NODE_ENV === 'production',
				sameSite: 'lax',
				maxAge: tokenExpiration,
			});
		},
		/**
		 * Remove the access token cookie from the client.
		 */
		removeSessionCookie() {
			// Remove access token cookie
			this.res?.clearCookie('sessionCookie', {
				httpOnly: true,
				secure: process.env.NODE_ENV === 'production',
				sameSite: 'lax',
				path: '/', // ðŸ‘ˆ important
			});
		},
		clearReqBody() {
			if (this.req) {
				this.req.body = undefined;
			}
		},
	};

	return authService;
};
